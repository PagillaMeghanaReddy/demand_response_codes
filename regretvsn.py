#!/usr/bin/env python
# coding: utf-8

# In[5]:


# -*- coding: utf-8 -*-
"""MABAlgosimluation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KpgL5ju2oqye1GerWlDArsJZq4jeunDS
"""

import numpy as np
import pickle
import matplotlib.pyplot as plt
import math
import random

def myalgo_multiunitsetpositive(probabilityplus,probabilityminus,karr,cost,D,n,C):
  pot_cost=np.zeros(n)
  for i in range(n):
    pot_cost[i]=(C*(1-probabilityplus[i])*probabilityminus[i] + probabilityminus[i]*cost[i])/probabilityplus[i]
  sorted_index = np.argsort(pot_cost)
  small = []
  iSmall=0
  tempSmall=[]
  big = []
  first=0
  iBig=0
  tempBig=[]
  probSum=0
  bl=0
  small_setsum=0
  for i in sorted_index:
    for x in range(karr[i]+1):
        if(x==0):
          continue
        if((small_setsum + probabilityplus[i]) < D ):
            # if(first==0):
            #   first=-1
            bl=True
            tempSmall.append(i)
            small_setsum = small_setsum+probabilityplus[i]
        else:
            # if(first==0):
            #   first=1
            #   small.append([])
            bl=False
            tempBig.append(i)
        if bl==False:
            if(len(tempSmall)!=0):
                small.append(tempSmall)
                iSmall=iSmall+1
            tempSmall=[]
        else:
            if(len(tempBig)!=0):
                big.append(tempBig)
                iBig=iBig+1
            tempBig=[]

  if bl==False:
        if(len(tempBig)!=0):
            big.append(tempBig)
  else:
      if(len(tempSmall)!=0):
          small.append(tempSmall)
        

  sum=0
  for i in range(n):
    sum=sum+C*karr[i]*(1-probabilityplus[i])*(probabilityminus[i]) + cost[i]*probabilityminus[i]*karr[i]
  mini=sum
  output_real1=np.zeros(n)
  sm_temp=[]
  i=0
  for sm in small:
    sm_temp=sm_temp+sm
    if(i==len(big)):
      break;
    for bm in big[i]: 
      output_tempo=np.zeros(n)
      output_tempo[bm]=1
      for sm1 in sm_temp:
        output_tempo[sm1]+=1
      ans=compute_objective(cost, probabilityplus, probabilityminus ,n, D, C, output_tempo)
      
      if((mini>ans)):
        mini=ans
        output_real1=output_tempo
        small_set_real=[]
        big_set_real=[]
        for sm1 in sm_temp:
          small_set_real.append(sm1);
        big_set_real.append(bm);
    i+=1
  if(len(big)!=0 and len(small)!=0):
      return (mini,output_real1)
      # return (mini,output_real1,small_set_real,big_set_real) 
             
  # for sm1 in sm_temp:
  #     output_real1[sm1]+=1
  #     # small_set_real.append(sm1);
  # mini=compute_objective(cost, probability, n, D, C, output_real1)

  return (mini,output_real1)
  # small_set_real,big_set_real)#return minimum value obtained



def myalgo_multiunitsetnegative(probabilityplus,probabilityminus,karr,cost,D,n,C):
  pot_cost=np.zeros(n)
  for i in range(n):
    pot_cost[i]=(C*(1-probabilityplus[i]) + cost[i])
  sorted_index = np.argsort(pot_cost)
  small = []
  iSmall=0
  tempSmall=[]
  big = []
  first=0
  iBig=0
  tempBig=[]
  small_setsum=0
  probSum=0
  bl=0
  for i in sorted_index:
    for x in range(karr[i]+1):
        if(x==0):
          continue
        if((small_setsum + probabilityminus[i]) < D ):
            # if(first==0):
            #   first=-1
            bl=True
            tempSmall.append(i)
            small_setsum = small_setsum+probabilityminus[i]
        else:
            # if(first==0):
            #   first=1
            #   small.append([])
            bl=False
            tempBig.append(i)
        if bl==False:
            if(len(tempSmall)!=0):
                small.append(tempSmall)
                iSmall=iSmall+1
            tempSmall=[]
        else:
            if(len(tempBig)!=0):
                big.append(tempBig)
                iBig=iBig+1
            tempBig=[]

  if bl==False:
        if(len(tempBig)!=0):
            big.append(tempBig)
  else:
      if(len(tempSmall)!=0):
          small.append(tempSmall)
        
  sum=0
  for i in range(n):
    sum=sum+C*karr[i]*(1-probabilityplus[i])*(probabilityminus[i]) + cost[i]*probabilityminus[i]*karr[i]
  mini=sum
  output_real1=np.zeros(n)
  sm_temp=[]
  i=0
  for sm in small:
    sm_temp=sm_temp+sm
    if(i==len(big)):
      break;
    for bm in big[i]: 
      output_tempo=np.zeros(n)
      output_tempo[bm]=1
      for sm1 in sm_temp:
        output_tempo[sm1]+=1
      ans=compute_objective(cost, probabilityplus, probabilityminus ,n, D, C, output_tempo)
      if(mini>ans):
        mini=ans
        output_real1=output_tempo
        small_set_real=[]
        big_set_real=[]
        for sm1 in sm_temp:
          small_set_real.append(sm1);
        big_set_real.append(bm);
    i+=1
  if(len(big)!=0 and len(small)!=0):
      return (mini,output_real1)
      # small_set_real,big_set_real) 
             
  # for sm1 in sm_temp:
  #     output_real1[sm1]+=1
  #     # small_set_real.append(sm1);
  # mini=compute_objective(cost, probabilityplus, probabilityminus ,n, D, C, output_real1)

  return (mini,output_real1)
  # ,small_set_real,big_set_real)#return minimum value obtained

def myalgo_multiunitset(probability,karr,cost,D,n,C):
  pot_cost=np.zeros(n)
  for i in range(n):
    pot_cost[i]=(C*(1-probability[i])*probability[i] + probability[i]*cost[i])/probability[i]
  sorted_index = np.argsort(pot_cost)
  small = []
  iSmall=0
  tempSmall=[]
  big = []
  first=0
  iBig=0
  tempBig=[]
  probSum=0
  bl=0
  small_setsum=0
  for i in sorted_index:
    for x in range(karr[i]+1):
        if(x==0):
          continue
        if((small_setsum + probability[i]) < D ):
            # if(first==0):
            #   first=-1
            bl=True
            tempSmall.append(i)
            small_setsum = small_setsum+probability[i]
        else:
            # if(first==0):
            #   first=1
            #   small.append([])
            bl=False
            tempBig.append(i)
        if bl==False:
            if(len(tempSmall)!=0):
                small.append(tempSmall)
                iSmall=iSmall+1
            tempSmall=[]
        else:
            if(len(tempBig)!=0):
                big.append(tempBig)
                iBig=iBig+1
            tempBig=[]

  if bl==False:
        if(len(tempBig)!=0):
            big.append(tempBig)
  else:
      if(len(tempSmall)!=0):
          small.append(tempSmall)
        

  sum=0
  for i in range(n):
    sum=sum+C*karr[i]*(1-probability[i])*(probability[i]) + cost[i]*probability[i]*karr[i]
  mini=sum
  output_real1=np.zeros(n)
  sm_temp=[]
  i=0
  for sm in small:
    sm_temp=sm_temp+sm
    if(i==len(big)):
      break;
    for bm in big[i]: 
      output_tempo=np.zeros(n)
      output_tempo[bm]=1
      for sm1 in sm_temp:
        output_tempo[sm1]+=1
      ans=compute_objective(cost, probability, probability ,n, D, C, output_tempo)
      if(mini>ans):
        mini=ans
        output_real1=output_tempo
        small_set_real=[]
        big_set_real=[]
        for sm1 in sm_temp:
          small_set_real.append(sm1);
        big_set_real.append(bm);
    i+=1
  if(len(big)!=0 and len(small)!=0):
      return (mini,output_real1)
      # ,small_set_real,big_set_real) 
             
  # for sm1 in sm_temp:
  #     output_real1[sm1]+=1
  #     # small_set_real.append(sm1);
  # mini=compute_objective(cost, probability, probability,n, D, C, output_real1)

  return (mini,output_real1)
          # ,small_set_real,big_set_real)#return minimum value obtained

def computefunction(karr,cost,probability,n,D,C,ans_temp):
    sum=0
    sumpixi=0
    sumxsqrpi=0
    sumpixici=0
    for i in range(n):
      sumpixi=sumpixi+ans_temp[i]*probability[i]
      sumxsqrpi=sumxsqrpi+ans_temp[i]*probability[i]*(1-probability[i])
      sumpixici=sumpixici+probability[i]*ans_temp[i]*cost[i]

    return (sumpixi-D)*(sumpixi-D)*C + (sumxsqrpi)*C + sumpixici 






def compute_objective(cost, probabilityplus, probabilityminus ,n, D, C, output_tempo):
  sum=0
  for i in range(n):
    sum=sum+C*output_tempo[i]*(1-probabilityplus[i])*(probabilityminus[i]) + cost[i]*probabilityminus[i]*output_tempo[i]
  return sum

  


flagset=False
C = float(input("Cost for buying electricity"))
c_max = float(input("max cost of the customer"))
 
index = 0
# n=10
regret_versus_n=[]
no_of_agents=[10,20,30,40,50]
for n in no_of_agents:
    cost = c_max*np.random.rand(n,1)
    probability = np.random.rand(n,1)
    karr = list(np.random.randint(low=1, high=5, size=n)) 

    no_of_iterations=100000
    Dt=np.zeros(no_of_iterations+1)
    for i in range(no_of_iterations+1):
      temp=0
      for i1 in range(n):
        temp+=karr[i1]
      Dt[i] = random.randint(2, math.ceil(temp/4))
    no_of_samples=4
    sum_regret_sample=[]
    sum_regret1_sample=[]
    sum_time=[]
    for t in range(no_of_iterations-1):
      sum_time.append(t+2)

    for s in range(no_of_iterations-1):
      sum_regret_sample.append(0)
      sum_regret1_sample.append(0)

    for nfs in range(no_of_samples):
      t=1
      Xt = np.zeros(n)
      xt=np.zeros(n)
      sum_Xt=np.zeros(n)
      sum_xt=np.zeros(n)
      checknegactive=0
      regret=[]
      regret1=[]
      time=[]
      sum_regret=0
      sum_regret1=0
      for i in range(n):
        sum_xt[i]=karr[i]
        xt[i]=karr[i]

      for i in range(n):
        x_it=np.random.binomial(n=karr[i], p=probability[i])
        Xt[i]=x_it
        sum_Xt[i]=x_it


      #getting probability hat
      phat=np.zeros(n)
      phatplus=np.zeros(n)
      phatminus=np.zeros(n)

      for i in range(n):
        phat_it=Xt[i]/karr[i]
        phat[i]=phat_it
        phatplus[i]=1
        phatminus[i]=0

      n_i=np.zeros(n)
      for i in range(n):
        n_i[i]=karr[i]
      probgraph=[]
      #loops t=2....T
      t=2
      while(t<=no_of_iterations):
        if(t%1000==0):
          print("t:"+str(t)+"noos sample"+str(nfs))

        checksum=0
        for i in range(n):
          checksum=checksum+probability[i]*karr[i]

        ststar=np.zeros(n)

        if(checksum>=Dt[t]):
          (ministstar,ststar)=myalgo_multiunitset(probability,karr,cost,Dt[t],n,C)
        else:
          for i in range(n):
            ststar[i]=karr[i]


        for i in range(n):
          lnval=math.log(t)
          x_sqr_var=math.sqrt((2*lnval)/(n_i[i]))
          phatplus[i]=phat[i]+x_sqr_var
          phatminus[i]=phat[i]-x_sqr_var
          if(phatplus[i]>1):
            phatplus[i]=1
          if(phatminus[i]<0):
            phatminus[i]=0

        checksumphatplus=0
        checksumphatminus=0
        for i in range(n):
          checksumphatplus+=phatplus[i]*karr[i]
          checksumphatminus+=phatminus[i]*karr[i]

        ststarminus=np.zeros(n)
        if(checksumphatminus>=Dt[t]):
            (ministstarminus,ststarminus)=myalgo_multiunitsetnegative(phatplus,phatminus,karr,cost,Dt[t],n,C)
        else:
          for i in range(n):
            ststarminus[i]=karr[i]



        ststarplus=np.zeros(n)
        if(checksumphatplus>=Dt[t]):
          (ministstarplus,ststarplus)=myalgo_multiunitsetpositive(phatplus,phatminus,karr,cost,Dt[t],n,C)
        else:
          for i in range(n):
            ststarplus[i]=karr[i]


        sumstplus=0
        sumxiphatplus=0
        suminto=0
        sumxipiminusci=0
        for i in range(n):
          sumxiphatplus=sumxiphatplus+ststarplus[i]*phatplus[i]
          suminto=suminto+ststarplus[i]*(phatminus[i])*(1-phatplus[i])*C
          sumxipiminusci=sumxipiminusci+ststarplus[i]*phatminus[i]*cost[i]
        sumstplus=C*(sumxiphatplus-Dt[t])*(sumxiphatplus-Dt[t])+suminto+sumxipiminusci

        sumstminus=0
        sumxiphatminus=0
        suminto=0
        sumxipiminusci=0
        for i in range(n):
          sumxiphatminus=sumxiphatminus+ststarminus[i]*phatminus[i]
          suminto=suminto+ststarminus[i]*(phatminus[i])*(1-phatplus[i])*C
          sumxipiminusci=sumxipiminusci+ststarminus[i]*phatminus[i]*cost[i]
        sumstminus=C*(sumxiphatminus-Dt[t])*(sumxiphatminus-Dt[t])+suminto+sumxipiminusci


        select_set=np.zeros(n)
        if(sumstplus < sumstminus ):
          select_set=ststarplus
        else:
          flagset=True
          select_set=ststarminus
        for i in range(n):
          if(select_set[i]!=0):
            n_i[i]=n_i[i]+select_set[i]


        #calculating regret.....
        sum1=0
        sumxipi1=0
        suminto1=0
        sumxipixici1=0
        for i in range(n):
          sumxipi1=sumxipi1+select_set[i]*probability[i]
          suminto1=suminto1+select_set[i]*(probability[i])*(1-probability[i])  
          sumxipixici1=sumxipixici1+select_set[i]*probability[i]*cost[i]  
        sum1=C*(sumxipi1-Dt[t])*(sumxipi1-Dt[t])+C*(suminto1)+sumxipixici1 

        sum2=0
        sumxipi2=0
        suminto2=0
        sumxipixici2=0
        for i in range(n):
          sumxipi2=sumxipi2+ststar[i]*probability[i]
          suminto2=suminto2+ststar[i]*(probability[i])*(1-probability[i])  
          sumxipixici2=sumxipixici2+ststar[i]*probability[i]*cost[i]  
        sum2=C*(sumxipi2-Dt[t])*(sumxipi2-Dt[t])+C*(suminto2)+sumxipixici2 

        if((sum1-sum2)<0):
          regret.append(sum_regret)
          checknegactive=1
          # print("NEGATIVE.......................................................................")
        else:
          sum_regret=sum_regret+sum1-sum2
          regret.append(sum_regret)
        time.append(t)


        for i in range(n):
          Xt[i]=np.random.binomial(n=select_set[i], p=probability[i])

        for i in range(n):
          phat[i]=(sum_Xt[i]+Xt[i])/(sum_xt[i]+select_set[i])
          sum_Xt[i]=sum_Xt[i]+Xt[i]
          sum_xt[i]=sum_xt[i]+select_set[i]

        summprob=0
        for i in range(n):
          summprob+=((phatplus[i]-probability[i])*(phatplus[i]-probability[i]))
        probgraph.append(summprob)

        t+=1
      getsum=0
      print("len of regret....")
      print(len(regret))
      print("sum_regret_len....")
      print(len(sum_regret_sample))
      sum_regret_sample = [sum_regret_sample[i] + regret[i] for i in range(len(regret))] 
      sum_regret1_sample = [sum_regret1_sample[i] + regret1[i] for i in range(len(regret1))] 
      plt.plot(time,regret)
      plt.xlabel('Time') 
      plt.ylabel('Regret') 
      plt.title('regret-time graph') 
      plt.show()
      print(sum_regret_sample)
      print(sum_time)
      print("IS it negative...........")
      print(checknegactive)
    val=    sum_regret_sample[-1]
    val=val/no_of_samples
    regret_versus_n.append(val)

    
    


# In[7]:


plt.plot(no_of_agents,regret_versus_n)
plt.xlabel('no_of_agents') 
plt.ylabel('Regret') 

#   plt.title('regret-time graph') 



plt.show()

with open('regret_average_with_varyingn.pkl', 'wb') as handle:
    pickle.dump(regret_versus_n, handle, protocol=pickle.HIGHEST_PROTOCOL)


# In[ ]:




