# -*- coding: utf-8 -*-
"""SimulationMultiUnitC-vary.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PVu3vBWIkuhol1SUwDUN2G1GIpBGmvAU
"""

import numpy as np
import pickle
import matplotlib.pyplot as plt
import math
import random

def minknapsack_algo(probability,karr,cost,D,n,C):
  pot_cost=np.zeros(n)
  for i in range(n):
    pot_cost[i]=(C*(1-probability[i])*probability[i] + probability[i]*cost[i])/probability[i]
  sorted_index = np.argsort(pot_cost)
  small = []
  iSmall=0
  tempSmall=[]
  big = []
  first=0
  iBig=0
  tempBig=[]
  probSum=0
  bl=0
  small_setsum=0
  for i in sorted_index:
    for x in range(karr[i]+1):
        if(x==0):
          continue
        if((small_setsum + probability[i]) < D ):
            # if(first==0):
            #   first=-1
            bl=True
            tempSmall.append(i)
            small_setsum = small_setsum+probability[i]
        else:
            # if(first==0):
            #   first=1
            #   small.append([])
            bl=False
            tempBig.append(i)
        if bl==False:
            if(len(tempSmall)!=0):
                small.append(tempSmall)
                iSmall=iSmall+1
            tempSmall=[]
        else:
            if(len(tempBig)!=0):
                big.append(tempBig)
                iBig=iBig+1
            tempBig=[]

  if bl==False:
        if(len(tempBig)!=0):
            big.append(tempBig)
  else:
      if(len(tempSmall)!=0):
          small.append(tempSmall)
        

  sum=0
  for i in range(n):
    sum=sum+C*karr[i]*(1-probability[i])*(probability[i]) + cost[i]*probability[i]*karr[i]
  mini=sum
  output_real1=np.zeros(n)
  sm_temp=[]
  i=0
  for sm in small:
    sm_temp=sm_temp+sm
    if(i==len(big)):
      break;
    for bm in big[i]: 
      output_tempo=np.zeros(n)
      output_tempo[bm]=1
      for sm1 in sm_temp:
        output_tempo[sm1]+=1
      ans=compute_objective(cost, probability, probability ,n, D, C, output_tempo)
      if(mini>ans):
        mini=ans
        output_real1=output_tempo
        small_set_real=[]
        big_set_real=[]
        for sm1 in sm_temp:
          small_set_real.append(sm1);
        big_set_real.append(bm);
    i+=1
  if(len(big)!=0 and len(small)!=0):
      return (mini,output_real1)
      # ,small_set_real,big_set_real) 
             
  # for sm1 in sm_temp:
  #     output_real1[sm1]+=1
  #     # small_set_real.append(sm1);
  # mini=compute_objective(cost, probability, probability,n, D, C, output_real1)

  return (mini,output_real1)
          # ,small_set_real,big_set_real)#return minimum value obtained

def computefunction(karr,cost,probability,n,D,C,ans_temp):
    sum=0
    sumpixi=0
    sumxsqrpi=0
    sumpixici=0
    for i in range(n):
      sumpixi=sumpixi+ans_temp[i]*probability[i]
      sumxsqrpi=sumxsqrpi+ans_temp[i]*probability[i]*(1-probability[i])
      sumpixici=sumpixici+probability[i]*ans_temp[i]*cost[i]

    return (sumpixi-D)*(sumpixi-D)*C + (sumxsqrpi)*C + sumpixici 

def get_recursive(karr,cost,probability,n,D,C,ans_temp,index,lt):
    if index == n :
      min_temp=computefunction(karr,cost,probability,n,D,C,ans_temp)
      if(min_temp<lt[0]):
        lt[0]=min_temp
        lt[1]=ans_temp.copy()
    else:
      for i in range(karr[index]+1):
        ans_temp[index]=i
        get_recursive(karr,cost,probability,n,D,C,ans_temp,index+1,lt)  
        # ans_temp[index]=0

def optimal(karr1, cost1, probability1, n, D, C):
    ans_temp=np.zeros(n)
    ans=np.zeros(n)
    lt=[]
    lt.append(10000000000)
    lt.append(ans)
    get_recursive(karr,cost,probability,n,D,C,ans_temp,0,lt)
    return lt



def compute_objective(cost, probabilityplus, probabilityminus ,n, D, C, output_tempo):
  sum=0
  for i in range(n):
    sum=sum+C*output_tempo[i]*(1-probabilityplus[i])*(probabilityminus[i]) + cost[i]*probabilityminus[i]*output_tempo[i]
  return sum

num_samples = int(input("number of samples"))
#D = float(input("Demand shortage"))
C = [1.0,5.0,10.0,15.0,20.0,25.0]
c_max = [1.0,1.0,1.0,1.0,1.0,1.0]
avg_ratioyx = np.zeros(6)
worst_ratioyx = np.zeros(6)

avg_ratiozx = np.zeros(6)
worst_ratiozx = np.zeros(6)

num_agents = int(input("number of agents"))

index = 0
maxwa = 0
avg_y = np.zeros(6) #minknapsack
worst_y = np.zeros(6)

avg_x = np.zeros(6) #optimal
worst_x = np.zeros(6)

avg_z = np.zeros(6) #GLS
worst_z = np.zeros(6)
karr = list(np.random.randint(low=1, high=5, size=num_agents))

for c in C:
    for samples in range(num_samples):
        # print(n,samples)
        sum_karr=0
        for i in range(num_agents):
          sum_karr = sum_karr + karr[i]

        D = random.randint(2, math.ceil(sum_karr/4))
        # D = (n/4)*np.random.rand()
        cm = 1.0*c_max[index]
        cost = cm*np.random.rand(num_agents,1)

        probability = np.random.rand(num_agents,1)
        # (output,ans,selected_set_by_myalgo)=my_algo(cost,probability,n,D,C)
        # print("The set returned by papers algorithm:")
        # print(selected_set_by_myalgo);

        sum_prob = 0
        for i in range(num_agents):
          sum_prob = sum_prob + karr[i]*probability[i]
        
        y=0
        if sum_prob<D:
          output_set_minknapsack = np.zeros(num_agents)
          for i in range(num_agents):
            output_set_minknapsack[i] = karr[i]

          y=computefunction(karr,cost,probability,num_agents, D, C[index], output_set_minknapsack)
          print("aka....................................................................................")
        else:
          (y,output_set_minknapsack)=minknapsack_algo(probability,karr,cost,D,num_agents,C[index])# take return as the minimum value obtained 
        
        (x,optimal_set_output)=optimal(karr, cost, probability, num_agents, D, C[index])

        # (z,aaai_set_output)=aaai_algo(cost, probability, num_agents, D, C[index])

        sum_prob_y = 0
        for i in range(num_agents):
          if output_set_minknapsack[i] >0:
            sum_prob_y = sum_prob_y + probability[i]*output_set_minknapsack[i]

        sum_prob_x = 0
        for i in range(num_agents):
          if optimal_set_output[i]>0:
            sum_prob_x = sum_prob_x+probability[i]*optimal_set_output[i]

        print('sum_prob_optimal - D')
        print(sum_prob_x-D)
        print('sum_prob_minknapsack - D')
        print(sum_prob_y-D)

        # ratioyx = y/x
        # ratiozx = z/x
        # print("y:")
        # print(y)
        # print("x:")
        # print(x)
        print("The selected set by my algorithm ");
        print(output_set_minknapsack);
        print("The selected set by optimal algorithm ");
        print(optimal_set_output);
          
        # avg_ratioyx[index] = avg_ratioyx[index] + ratioyx
        # avg_ratiozx[index] = avg_ratiozx[index] + ratiozx

        avg_y[index] = avg_y[index] + y
        avg_x[index] = avg_x[index] + x
        # avg_z[index] = avg_z[index] + z        


        # if ratioyx > worst_ratioyx[index]:
        #     worst_ratioyx[index] = ratioyx
        # if ratiozx > worst_ratiozx[index]:
        #     worst_ratiozx[index] = ratiozx
        if y > worst_y[index]:
            worst_y[index] = y
        if x > worst_x[index]:
            worst_x[index] = x
        # if z > worst_z[index]:
        #     worst_z[index] = z
    index = index+1
# avg_ratioyx = avg_ratioyx/num_samples
# avg_ratiozx = avg_ratiozx/num_samples
avg_x = avg_x/num_samples
avg_y = avg_y/num_samples
# avg_z = avg_z/num_samples
pickle_out = open("worst_optimal_multi_varyc_offline.pickle","wb")
pickle_out1 = open("worst_minknapsack_multi_varyc_offline.pickle","wb")
pickle.dump(worst_x, pickle_out)
pickle.dump(worst_y,pickle_out1)

plt.plot(C,worst_x,'r', label='optimal algorithm') #optimal
# plt.plot(C,worst_x,'y', label='worst_x') 

plt.plot(C,worst_y,'b', label='minkpds') #minknapsack
# plt.plot(C,worst_y,'m', label='worst_y')

# plt.plot(C,avg_z,'k', label='GLS algorithm') #aaai
# # plt.plot(C,worst_z,'b', label='worst_z')

plt.legend(loc='upper left')
plt.xlabel('cost of buying electricity from market (C)')
plt.ylabel('Loss function value')
plt.savefig('offline_comparison.png')
plt.show()